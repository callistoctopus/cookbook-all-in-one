# What is JAR?  
**JAR** stands for Java ARchive. It's a file format based on the popular ZIP file format and is used for aggregating many files into one. Although JAR can be used as a general archiving tool, the primary motivation for its development was so that Java applets and their requisite components (.class files, images and sounds) can be downloaded to a browser in a single HTTP transaction, rather than opening a new connection for each piece. This greatly improves the speed with which an applet can be loaded onto a web page and begin functioning. The JAR format also supports compression, which reduces the size of the file and improves download time still further. Additionally, individual entries in a JAR file may be digitally signed by the applet author to authenticate their origin.

## Introduction
**JAR** file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A  JAR file is essentially a zip file that contains an optional **META-INF** directory. A JAR file can be created by the command-line jar tool, or by using the  java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.
In many cases, JAR files are not just simple archives of java classes files and/or resources. They are used as building blocks for applications and extensions. **The META-INF directory, if it exists, is used to store package and extension configuration data, including security, versioning, extension and services.**

## The META-INF directory
The following files/directories in the META-INF directory are recognized and interpreted by the Java 2 Platform to configure applications, extensions, class loaders and services:  

`MANIFEST.MF`  
The manifest file that is used to define extension and package related data.  

`INDEX.LIST`  
This file is generated by the new "-i" option of the jar tool, which contains location information for packages defined in an application or extension.  It is part of the JarIndex implementation and used by class loaders to speed up their class loading process.

`x.SF`  
The signature file for the JAR file.  'x' stands for the base file name.


`x.DSA`  
The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file.

`services/`  
This directory stores all the service provider configuration files.

## Main Attributes
Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:
* general main attributes  

  * **Manifest-Version**: Defines the manifest file version. The value is a legitimate version number, as described in the above spec.
  * **Created-By**: Defines the version and the vendor of the java implementation on top of which this manifest file is generated. This attribute is generated by the jar tool.
  * **Signature-Version**: Defines the signature version of the jar file. The value should be a valid version-number string.
  * **Class-Path**: The value of this attribute specifies the relative URLs of the extensions or libraries that this application or extension needs. URLs are separated by one or more spaces. The application or extension class loader uses the value of this attribute to construct its internal search path. 
* attribute defined for stand-alone applications: This attribute is used by stand-alone applications that are bundled into executable jar files which can be invoked by the java runtime directly by running "java -jar x.jar".
  * **Main-Class**: The value of this attribute is the class name of the main application class which the launcher will load at startup time. The value must not have the .class extension appended to the class name.

* attribute defined for extension identification: This attribute is used by extensions to define their unique identity.
  * **Extension-Name**: This attribute specifies a name for the extension contained in the Jar file. The name should be a unique identifier such as the name of the main package comprising the extension.
* attributes defined for extension and  package `versioning`  and `sealing` information: These attributes define features of the extension which the JAR file is a part of. The value of these attributes apply to all the packages in the JAR file, but can be overridden by per-entry attributes.
  * **Implementation-Title**: The value is a string that defines the title of the extension implementation.
  * **Implementation-Version**: The value is a string that defines the version of the extension implementation.
  * **Implementation-Vendor**: The value is a string that defines the organization that maintains the extension implementation.
  * **Implementation-Vendor-Id**: Deprecated: This attribute may be ignored in a future release. The value is a string id that uniquely defines the organization that maintains the  extension implementation.
  * **Implementation-URL**: Deprecated: This attribute may be ignored in a future release. This attribute defines the URL from which the extension implementation can be downloaded from.
  * **Specification-Title**: The value is a string that defines the title of the extension specification.
  * **Specification-Version**: The value is a string that defines the version of the extension specification.
  * **Specification-Vendor**: The value is a string that defines the organization that maintains the extension specification.
  * **Sealed**: This attribute defines whether this JAR file is sealed or not. The value can be either "true" or "false", case is ignored. If it is set to "true", then all the packages in the JAR file are defaulted to be sealed, unless they are defined otherwise individually.

### Class-Path Attribute
The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it requires. These relative URLs are treated relative to the code base from which the containing application was loaded.

An application (or, more generally, a JAR file) specifies the relative URLs of the libraries that it requires with the manifest attribute Class-Path. This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java virtual machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with a slash (/) are assumed to refer to JAR files. For example:

```
Class-Path: servlet.jar infobus.jar acme/beans.jar images/
```
### Package Sealing
JAR files and packages can be optionally sealed so that an package can enforce consistency within a version.

A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown.

A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package.

A sealed package is specified through the manifest attribute, Sealed, whose value is true or false (case irrelevant). For example:
```
Name: javax/servlet/internal/
Sealed: true
```
This specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file.

## Per-Entry Attributes
Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with.  If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:
```
Manifest-Version: 1.0
Created-By: 1.2 (Sun Microsystems Inc.)
Sealed: true
Name: foo/bar/
Sealed: false
```
It means that all the packages archived in a.jar are sealed, except that package foo.bar is not.

The per-entry attributes fall into the following groups:

* attributes defined for file contents:  
  * **Content-Type**: This attribute can be used to specify the MIME type and subtype of data for a specific file entry in the JAR file. The value should be a string in the form of type/subtype. For example "image/bmp" is an image type with a subtype of bmp (representing bitmap). This would indicate the file entry as an image with the data stored as a bitmap. RFC 1521 and 1522 discuss and define the MIME types definition.
* attributes defined for package versioning and sealing information: These are the same set of attributes defined above as main attributes that defines the extension package versioning and sealing information. When used as per-entry attributes, these attributes overwrites the main attributes but only apply to the individual file specified by the manifest entry.
* attribute defined for beans objects:
  * **Java-Bean**: Defines whether the specific jar file entry is a Java Beans object or not. The value should be either "true" or "false", case is ignored.
* attributes defined for signing: These attributes are used for signing and verifying purposes. More details here.
  * **x-Digest-y**: The name of this attribute specifies the name of the digest algorithm used to compute the digest value for the corresponding jar file entry. The value of this attribute stores the actual digest value. The prefix 'x' specifies the algorithm name and the optional suffix 'y'  indicates to which language the digest value should be verified against.
  * **Magic**: This is an optional attribute that can be used by applications to indicate how verifier should compute the digest value contained in the manifest entry.  The value of this attribute is a set of comma separated context specific strings. Detailed description is here.

## Signed JAR File

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are:

`META-INF/MANIFEST.MF`  
`META-INF/*.SF`  
`META-INF/*.DSA`  
`META-INF/*.RSA`  
`META-INF/SIG-*`  

Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed.
Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file.

## JAR Index

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files.
The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named `INDEX.LIST` in the META-INF directory of the root jar file. When the classloader loads the root jar file,  it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary.

## Service Provider

Files in the `META-INF/services` directory are service provider configuration files. A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers may be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers may also be made available by adding them to the applet or application class path or by some other platform-specific means.